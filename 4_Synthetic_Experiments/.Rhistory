}
if(i!=1){
beta_0s[[i]] = unlist(beta_0_hats[((b-N_samp)+1):b])
}
}
as.data.frame(beta_0s)
names(df)=seq(1,p)
df = as.data.frame(1 = beta_0s[[1]])
names(df)=seq(1,p)
boxplot(df)
df = as.data.frame(beta_0s)
boxplot(df)
names(df) =seq(1,p)
boxplot(df)
df$1 ==df$2
df$1 == df$2
df$1
df
all.equal(beta_0s)
beta_0s[[1]]
beta_0s[[1]] == beta_0s[[2]]
idx = c(rep(1,100), rep(2, 100), rep(3,100), rep(4,100), rep(5,100), rep(6,100), rep(7,100),
rep(8,100), rep(9,100), rep(10,100) )
idx[101:200]
list_of_trips <- Map(list, data, unlist(beta_debs, recursive = F), idx)
list_of_trips[[1]][[3]]
list_of_trips[[1]][3]
length(idx)
length(data)
length(unlist(beta_debs, recursive = F))
Map(list, c(1,2,3), matrix(NA, nrow=3,ncol=3), rep(1,10))
library(purrr) # map
library(splines) #bsplines
out_50_debiased <- readRDS("~/Downloads/GAPLA/Synthetic_Experiments/Model_A/Inference/out_50_debiased.RDS") #1000 because 100 samples for each p (p=10)
p = 10; N_samp = 100
get_debiased_est = function(out_storm, p, N_samp){
# extract debiased lasso estimates for all dimensions
beta_deb = list(); beta_deb = rep(list(beta_deb), 100); beta_deb = rep(list(beta_deb), p);
for(i in 1:p){
b = N_samp*i
if(i==1){
res = out_storm[1:b] #i.e. samples 1-10 for lambda = 0.1
}
if(i!=1){
res = out_storm[((b-N_samp)+1):b]
}
# start with unit 1
res = out_50_debiased[1:100]
# betas for each sample
beta_deb[[i]] = map(res, 1)
}
return(beta_deb)
}
# get debiased estimates for each dimension
beta_debs = get_debiased_est(out_50_debiased, 10, 100)
data_50 <- readRDS("~/Downloads/GAPLA/Synthetic_Experiments/Model_A/Simulations/data_50.RDS")
data = rep(data_50, p)
# Combine the lists into a list of pairs
list_of_pairs <- Map(list, data, unlist(beta_debs, recursive = F))
idx = c(rep(1,100), rep(2, 100), rep(3,100), rep(4,100), rep(5,100), rep(6,100), rep(7,100),
rep(8,100), rep(9,100), rep(10,100) )
list_of_trips <- Map(list, data, unlist(beta_debs, recursive = F), idx)
library(doParallel)
library(doRNG)
cl <- makeCluster(4)
start <- Sys.time()
registerDoParallel(cl)
registerDoRNG(seed = 123)
re_fit_50 <- foreach(k=list_of_trips, .packages = c("purrr", "splines",
"LaplacesDemon")) %dopar%{
setwd("~/Downloads/GAPLA/Synthetic_Experiments")
source("Functions_GAPLA.R")
# read data
data = k[[1]]
beta_deb = k[[2]]
idx = k[3]
# do the re-fitting
re_fit_res = re_fit(data, idx, max_iter=1000, tol=1e-8, m=10, beta_deb)
return(list(beta_0 = re_fit_res$beta0, f_hat = re_fit_res$f_orig))
}
library(splines)
check = bs(seq(1, 100), df=5, intercept = F)
dim(check)
length(phi[,1])
length(check[,1])
model1_times <- readRDS("~/luna/Paper_Code/Section 4/Reviews/Simulations/Simulated_Times/model1_times.RDS")
ma_lams_10 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/10_trials/ma_lams_10.RDS")
ma_lams_10
ma_lams_10$l_ebic
glasso
mb_lams_10 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/10_trials/mb_lams_10.RDS")
mb_lams
mb_lams_10
mc_lams_10 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/10_trials/mc_lams_10.RDS")
mc_lams_10
ma_lams_10 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/50_trials/ma_lams_10.RDS")
ma_lams_50 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/50_trials/ma_lams_50.RDS")
ma_lams_50
mb_lams_50 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/50_trials/mb_lams_50.RDS")
mb_lams_50
mc_lams_50 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Tuned_Parameter_Values/Graphical/50_trials/mc_lams_50.RDS")
mc_lams_50
res1 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res1.RDS")
# Results from simulations -------------------------------------------
setwd("~/Downloads/RSE/4_Synthetic_Experiments")
source("Functions_Section_4.R")
library(purrr)
library(pracma) #for logspace
library(Matrix)
library(phonTools)
library(QZ)
library(purrr)
library(matrixStats)
library(complexplus)
library(psych)
library(pracma)
library(hawkes)
res1 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res1.RDS")
res2 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res2.RDS")
res3 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res3.RDS")
res4 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res4.RDS")
res5 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res5.RDS")
res6 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res6.RDS")
res7 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res7.RDS")
res8 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res8.RDS")
res9 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res9.RDS")
# check
res = res1
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
theta_list[[4]]
theta_list[[5]]
gt = gt_12
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
gt = gt_12
check = lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)
lapply(check, mean)
unlist(check)
mean(check)
mean(unlist(check))
unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2))
pc_list = lapply(z_list, partial_co)
lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
F1
metrics = function(res, gt)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
return(list(F1 = F1, av_mse = av_mse))
}
metric(res1, gt_12)
metrics(res1, gt_12)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
return(list(F1 = F1, av_mse = av_mse))
}
metrics(res1, gt_12)
metrics(res2, gt_48)
metrics(res3, gt_96)
ground_truth = Get_ground_truth(P_vec, 2, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res4, gt_12)
metrics(res5, gt_48)
metrics(res6, gt_96)
# model c
ground_truth = Get_ground_truth(P_vec, 3, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res7, gt_12)
metrics(res8, gt_48)
metrics(res9, gt_96)
res9[[1]]$theta
res9[[1]]$z
performance_measures
# Results from simulations -------------------------------------------
setwd("~/Downloads/RSE/4_Synthetic_Experiments")
source("Functions_Section_4.R")
library(purrr)
library(pracma) #for logspace
library(Matrix)
library(phonTools)
library(QZ)
library(purrr)
library(matrixStats)
library(complexplus)
library(psych)
library(pracma)
library(hawkes)
res1 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res1.RDS")
res2 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res2.RDS")
res3 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res3.RDS")
res4 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res4.RDS")
res5 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res5.RDS")
res6 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res6.RDS")
res7 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res7.RDS")
res8 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res8.RDS")
res9 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res9.RDS")
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
return(list(F1 = F1, av_mse = av_mse))
}
metrics(res1, gt_12)
metrics(res2, gt_48)
metrics(res3, gt_96)
ground_truth = Get_ground_truth(P_vec, 2, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res4, gt_12)
metrics(res5, gt_48)
metrics(res6, gt_96)
# model c
ground_truth = Get_ground_truth(P_vec, 3, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res7, gt_12)
metrics(res8, gt_48)
metrics(res, gt_96)
metrics(res9, gt_96)
# Results from simulations -------------------------------------------
setwd("~/Downloads/RSE/4_Synthetic_Experiments")
source("Functions_Section_4.R")
library(purrr)
library(pracma) #for logspace
library(Matrix)
library(phonTools)
library(QZ)
library(purrr)
library(matrixStats)
library(complexplus)
library(psych)
library(pracma)
library(hawkes)
res1 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res1.RDS")
res2 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res2.RDS")
res3 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res3.RDS")
res4 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res4.RDS")
res5 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res5.RDS")
res6 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res6.RDS")
res7 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res7.RDS")
res8 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res8.RDS")
res9 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/50_trials/res9.RDS")
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
return(list(F1 = F1, av_mse = av_mse))
}
metrics(res1, gt_12)
gt_96 = map(ground_truth,3)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res1, gt_12)
metrics(res2, gt_48)
metrics(res3, gt_96)
ground_truth = Get_ground_truth(P_vec, 2, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res4, gt_12)
metrics(res5, gt_48)
metrics(res6, gt_96)
ground_truth = Get_ground_truth(P_vec, 3, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res7, gt_12)
metrics(res8, gt_48)
metrics(res9, gt_96)
res = res1
theta_list = map(res, 1)
z_list = map(res, 2)
pc_list = lapply(z_list, partial_co)
pc_list[[1]]
image(pc_list[[1]])
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
gt = gt_12
gt
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
gt_12 = map(ground_truth,1)
gt = gt_12
gt$pc
pc_list[[1]]
View(pc_list)
logspace(-5,1,,100)
logspace(-5,1,100)
log(logspace(-5,1,100))
log(logspace(-3,1,100))
install.packages("pROC")
library(pROC)
roc
setwd("~/Downloads/RSE/4_Synthetic_Experiments")
source("Functions_Section_4.R")
library(purrr)
library(pracma) #for logspace
library(Matrix)
library(phonTools)
library(QZ)
library(purrr)
library(matrixStats)
library(complexplus)
library(psych)
library(pracma)
library(hawkes)
# Load results ------------------------------------------------------------
res1 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res1.RDS")
res2 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res2.RDS")
res3 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res3.RDS")
res4 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res4.RDS")
res5 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res5.RDS")
res6 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res6.RDS")
res7 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res7.RDS")
res8 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res8.RDS")
res9 <- readRDS("~/Downloads/RSE/4_Synthetic_Experiments/Graphical/Simulations/10_trials/res9.RDS")
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
gt_12 = map(ground_truth,1)
gt_12$pc
# get ground truth
P_vec = c(12,48,96)
ground_truth = Get_ground_truth(P_vec, 1, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
library(pROC)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x)})
auc_list = lapply(roc_obj, auc)
auc_obj = mean(unlist(auc_list))
return(list(F1 = F1, av_mse = av_mse, av_AUC = auc_obj))
}
metrics(res1, gt_12)
warnings()
res = res1
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
gt = gt_13
gt = gt_12
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
av_mse
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x)})
roc(true_pc, est_pc_vec[[1]])
est_pc_vec[[1]]
true_pc
length(unique(true_pc))
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
# Check if the response has more than two levels
if (length(unique(true_pc)) > 2) {
roc_obj = lapply(est_pc_vec, function(x){multiclass.roc(true_pc, x)})
auc_list = lapply(roc_obj, auc)
} else {
# Use roc for binary classification
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x)})
auc_list = lapply(roc_obj, auc)
}
auc_obj = mean(unlist(auc_list))
return(list(F1 = F1, av_mse = av_mse, av_AUC = auc_obj))
}
metrics(res1, gt_12)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
# Check if the response has more than two levels
if (length(unique(true_pc)) > 2) {
roc_obj = lapply(est_pc_vec, function(x){multiclass.roc(true_pc, x, direction="<")})
auc_list = lapply(roc_obj, auc)
} else {
# Use roc for binary classification
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x, direction="<")})
auc_list = lapply(roc_obj, auc)
}
auc_obj = mean(unlist(auc_list))
return(list(F1 = F1, av_mse = av_mse, av_AUC = auc_obj))
}
metrics(res1, gt_12)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
# Check if the response has more than two levels
if (length(unique(true_pc)) > 2) {
roc_obj = lapply(est_pc_vec, function(x){multiclass.roc(true_pc, x, direction=">")})
auc_list = lapply(roc_obj, auc)
} else {
# Use roc for binary classification
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x, direction=">")})
auc_list = lapply(roc_obj, auc)
}
auc_obj = mean(unlist(auc_list))
return(list(F1 = F1, av_mse = av_mse, av_AUC = auc_obj))
}
metrics(res1, gt_12)
metrics = function(res, gt){
theta_list = map(res, 1)
z_list = map(res, 2)
r = map(res, 3)
av_mse = mean( unlist(lapply(theta_list, function(x) performance_measures(x, gt$theta, F)$l2)) )
pc_list = lapply(z_list, partial_co)
F1 = mean(unlist(lapply(pc_list, function(x) performance_measures(x, gt$pc, T)$F1)))
# vectorise matrices for AUROC
true_pc = as.vector(gt$pc)
est_pc_vec = lapply(pc_list, as.vector)
# Check if the response has more than two levels
if (length(unique(true_pc)) > 2) {
roc_obj = lapply(est_pc_vec, function(x){multiclass.roc(true_pc, x, direction="<")})
auc_list = lapply(roc_obj, auc)
} else {
# Use roc for binary classification
roc_obj = lapply(est_pc_vec, function(x){roc(true_pc, x, direction="<")})
auc_list = lapply(roc_obj, auc)
}
auc_obj = mean(unlist(auc_list))
return(list(F1 = F1, av_mse = av_mse, av_AUC = auc_obj))
}
metrics(res1, gt_12)
metrics(res2, gt_48)
metrics(res3, gt_96)
ground_truth = Get_ground_truth(P_vec, 2, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res4, gt_12)[1:2]
metrics(res4, gt_12)
metrics(res5, gt_48)
metrics(res6, gt_96)
# model c
ground_truth = Get_ground_truth(P_vec, 3, 0.0628)
gt_12 = map(ground_truth,1)
gt_48 = map(ground_truth,2)
gt_96 = map(ground_truth,3)
metrics(res7, gt_12)
metrics(res8, gt_48)
metrics(res9, gt_96)
